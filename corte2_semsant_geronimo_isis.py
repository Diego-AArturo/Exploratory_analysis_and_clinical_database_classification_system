# -*- coding: utf-8 -*-
"""Corte2_SemSant_Geronimo_ISIS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TbOzoWMuKrsZD_f9PeVcCktwEeDCPWcZ

#Librerias
"""

import pandas as pd
import seaborn as sn
import numpy as np
import matplotlib.pyplot as plt
import datetime
import math
import requests
import scipy.stats as stats
import matplotlib.animation as animation
from sklearn.metrics import confusion_matrix, precision_score, recall_score, f1_score, roc_auc_score, classification_report
from sklearn.cluster import KMeans
from IPython.display import HTML
from google.colab import files
from datetime import datetime
from sklearn import preprocessing
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import RobustScaler
from sklearn.preprocessing import PowerTransformer
from imblearn.pipeline import make_pipeline
import warnings
from imblearn.under_sampling import RandomUnderSampler
from imblearn.over_sampling import RandomOverSampler
from sklearn.datasets import make_classification
from imblearn.over_sampling import SMOTE
from collections import Counter
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier

"""# Apertura de archivo"""

! rm -r yuki
! git clone https://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:x-oauth-basic@github.com/ingrid183/yuki.git

"""# Ajuste del dataframe"""

doc='/content/yuki/Datos (2).xlsx'#
#doc='/content/ISIS_SEMANA7_DATA - BU.XLSX.xlsx'
df = pd.read_excel(doc, header=0, index_col=0)

names=df.columns
y,x=df.shape
df.isnull().sum()

"""#Eliminar columnas vacias"""

df_del=df.copy()
for na in names:
  if df_del[na].isnull().sum()==(y):
    print(na)
    del df_del[na]

"""#reemplazar valores 

"""

#reemplazar valores 
df_del['Indicador Anulación'] = df_del['Indicador Anulación'].replace('X',1)
df_del['Indicador Anulación'] = df_del['Indicador Anulación'].replace(np.nan,0)

"""# Eliminar citas asignadas"""

df_del = df_del.drop(df_del[df_del['Tipo de Cita'] == 'ASIGNADA'].index)
df_del = df_del.reset_index(drop=True)

"""#Creación y desecho de variables"""

#Creación de la variable edad
f=(df_del['Fecha']-df_del['Fecha naci.'])/365
f.tolist()
n_f = [f[i].days for i in range(len(f))]
df_del.insert(9,'Edad',n_f)

# Creación de la variable tiempo de espera
tiem_espera=df_del['Fecha']-df_del['Fecha crea.']
espera = [tiem_espera[i].days for i in range(len(tiem_espera))]
df_del.insert(10,'Tiempo Espera (dias)',espera)
df_del['Tiempo Espera (dias)'] = df_del['Tiempo Espera (dias)'].astype(float)

df_del['Indicador Anulación'] = df_del['Indicador Anulación'].replace(np.nan,0)

sn.histplot(x='Edad',hue='Indicador Anulación',data=df_del, palette=['grey', 'green'])

X=0
#Creación de la variable rangos de edad  ///ACOPLAR y ver como putas organizarlo en orden

X = df_del.loc[:, ["Edad"]]
kmeans = KMeans(n_clusters=12,n_init=25)
grupos_edades = {
    7: 1.0,   # '0-9'
    2: 2.0,   # '10-19'
    10: 3.0,  # '20-27'
    1: 4.0,   # '28-33'
    8: 5.0,   # '34-40'
    3: 6.0,   # '41-47'
    9: 7.0,   # '48-53'
    6: 8.0,   # '54-59'
    0: 9.0,   # '60-65'
    5: 10.0,  # '20-27'
    11: 11.0, # '73-79'
    4: 12.0,  # '80-98'
}
df_del.insert(4, 'Grupo Etario', pd.Series(kmeans.fit_predict(X)).map(grupos_edades))
df_del['Grupo Etario'] = df_del['Grupo Etario'].astype(float)

anos = df_del['Fecha'].dt.year.unique()#Guarda los años de las citas
anos = [str(a) for a in anos] # Guarda los años en formato str
dfestivos=[]

for an in anos:
  url = f"https://api.generadordni.es/v2/holidays/holidays?country=CO&year={an}" # llamado de API por año
  response = requests.get(url, verify=False)
  j=response.json() # Se guardan los datos de cada festivo en una lista
  for i in range(len(j)):
    k=j[i] # se recorre cada posicion de la lista, dentro de cada posicion hay un diccionario
    #display(k)
    k.get('end') # En el diccionario se busca la fecha donde finaliza el dia festivo
    fecha_str =k.get('end').split("T")[0] # separa la cadena de texto por la letra 'T'
    fecha_dt = datetime.strptime(fecha_str, "%Y-%m-%d")  
    dfestivos.append(fecha_dt)

df_del.insert(10,'Festivo',np.zeros(len(df_del))) # Se crea la columna de "festivos" llena de 0

festivos = [pd.to_datetime(f) for f in dfestivos]

df_del['Fecha_antes']=df_del['Fecha']-pd.offsets.Day(1)
cumple=df_del.loc[:,'Fecha naci.'].to_list()

for index, row in df_del.iterrows():
    fecha = pd.to_datetime(row['Fecha'])
    fecha_a=pd.to_datetime(row['Fecha_antes'])
# En la columna "festivos" El 1 indica que el festivo ocurrio antes de la cita
    if fecha_a in festivos:
        df_del.loc[index, 'Festivo'] = 1

# En la columna "festivos" El 2 indica que el festivo ocurrio el mismo dia de la cita         
    if fecha in festivos:
        df_del.loc[index, 'Festivo'] = 2

'''
#Creación de la variable rangos de edad
rangos = [-1, 6, 12, 18, 26, 59, np.inf]
labels = ['primera Infancia', 'infancia', 'adolescencia', 'juventud', 'adultez', 'vejez']
df_del.insert(4, 'Grupo Etario', pd.cut(df_del['Edad'], bins=rangos, labels=labels).astype(str))
'''

# Creación de la variable Día Semana
dias_semana = {
    0: 1.0, # 'Lunes'
    1: 2.0, # 'Martes'
    2: 3.0, # 'Miércoles'
    3: 4.0, # 'Jueves'
    4: 5.0, # 'Viernes'
    5: 6.0, # 'Sábado'
    6: 7.0  # 'Domingo'
}
df_del.insert(2, 'Día Semana', df_del['Fecha'].dt.weekday.map(dias_semana))

temporadas = {
    1: 2, # 'Enero_alta'
    2: 2, # 'Febrero_alta'
    3: 2, # 'Marzo_alta'
    4: 1, # 'Abril_intermedio'
    5: 1, # 'Mayo_intermedio'
    6: 1, # 'Junio_intermedio'
    7: 1,  # 'Julio_intermedio'
    8: 1,  # 'Agosto_intermedio'
    9: 1,  # 'Septiembre_intermedio'
    10: 0,  # 'Octubre_bajo'
    11: 0,  # 'Noviembre_bajo'
    12: 2  # 'Diciembre_alto'
}
df_del.insert(4, 'Temporadas', df_del['Fecha'].dt.month.map(temporadas))

df_del['Hora'] = df_del['Hora'].apply(lambda x: x.hour).astype(float)

#crecion de variable tiempo de anulacion
timea=df_del['Fecha de anulación']-df_del['Fecha crea.']
espera = [timea[i].days for i in range(len(timea))]
df_del.insert(11,'Tiempo anulacion (dias)',espera)
df_del['Tiempo anulacion (dias)'] = df_del['Tiempo anulacion (dias)'].astype(float)
df_del['Tiempo anulacion (dias)'] = df_del['Tiempo anulacion (dias)'].replace(np.nan,0)

df_del['Ayuno']=np.zeros(len(df_del))
for index, row in df_del.iterrows():
    comentario = row['Comentario']
    if isinstance(comentario, str):
      if comentario.upper().find('AYUNO') != -1:
          df_del.loc[index, 'Ayuno'] = 1
          #print(f"El caracter {cuerpo} se encuentra en la cadena: {comentario}")

'''
del df_del['Canceladas']
del df_del['Atendidas']
del df_del['Porcentaje de Anulación']
'''

df_del.insert(5,'Atendidas', np.zeros(len(df_del)))
df_del.insert(5,'Canceladas', np.zeros(len(df_del)))

DOCUS = []
for i in range(len(df_del['Num Dcto'])):
  if df_del['Num Dcto'][i] in DOCUS:
      h = len(DOCUS) - list(reversed(DOCUS)).index(df_del['Num Dcto'][i]) - 1
      if df_del['Indicador Anulación'][h] == 0:
          df_del.loc[i, 'Canceladas']= df_del.loc[h, 'Canceladas'] # h es el viejo e i es el nuevo
          df_del.loc[i, 'Atendidas'] = df_del.loc[h, 'Atendidas'] + 1
      else:
          df_del.loc[i, 'Canceladas']= df_del.loc[h, 'Canceladas'] + 1
          df_del.loc[i, 'Atendidas'] = df_del.loc[h, 'Atendidas']  
  DOCUS.append(df_del['Num Dcto'][i])

porc = (df_del['Canceladas']*100)/(df_del['Canceladas']+df_del['Atendidas'])
porc.tolist()
df_del.insert(9,'Porcentaje de Anulación', porc)
df_del['Porcentaje de Anulación'] = df_del['Porcentaje de Anulación'].replace(np.nan,0)

'''#Personas con varias citas
df_del['Num Dcto'].value_counts()
#Citas de esa persona
for i in range(len(df_del['Num Dcto'])):
  if df_del['Num Dcto'][i]==9673:
    display(df_del.loc[i:i])
'''

'''
coun = df_del.groupby(['Num Dcto', 'Tipo de Cita'])['Num Dcto'].count().unstack()

# Renombramos las columnas para que queden más claras
coun.columns = ['ATENDIDAS', 'CANCELADAS']
coun['ATENDIDAS']=coun['ATENDIDAS'].replace(np.nan,0)
coun['CANCELADAS']=coun['CANCELADAS'].replace(np.nan,0)

coun['Porcentaje de cancelación']=round(coun['CANCELADAS']/(coun['ATENDIDAS']+coun['CANCELADAS']),1)

# Resetear el índice para que los números aparezcan como una columna más
coun = coun.reset_index()

# Unimos la tabla de recuento con el DataFrame original
df_del = df_del.merge(coun, on='Num Dcto', how='left')
'''

# Asigna los nombres de columna del dataframe a la lista names y los muestra
names=df_del.columns
names

"""#Eliminación de datos atipicos"""

# Elimina los datos atipicos
df_del = df_del.drop(5273)
df_del = df_del.drop(7790) 

df_del = df_del.reset_index(drop=True)#(drop=True)

# Permite comprobar si datos atipicos fueron eliminados
j=0
while j<len(df_del['Tiempo Espera (dias)']):
 if df_del['Tiempo Espera (dias)'][j]>=500:
   display(df_del[j:j+1])
 j+=1

df_del = df_del.drop(10942)
df_del = df_del.drop(25800)
df_del = df_del.drop(26761)
df_del = df_del.reset_index(drop=True)

j=0
while j<len(df_del['Hora']):
 if df_del['Hora'][j]<=5:
   display(df_del[j:j+1])
 j+=1

df_del = df_del.drop(6136)
df_del = df_del.reset_index(drop=True)


j=0
while j<len(df_del['Tiempo anulacion (dias)']):
 if df_del['Tiempo anulacion (dias)'][j]>=300:
   display(df_del[j:j+1])
 j+=1

names=df_del.columns
names

"""# Desecho de variables"""



# Elimina variables innecesarias
del df_del['Apellido1'],
del df_del['Apellido2']
del df_del['Nombre1']
del df_del['Nombre2']
del df_del['Clase Episodio']
del df_del['Fecha mod.']
del df_del['Causal modificación']
del df_del['Aseguradora']
del df_del['Paciente']
#del df_del['Sala cita']
del df_del['ID citación']
del df_del['Fecha naci.' ]
del df_del['Num Cita']
del df_del['Modif. por']
del df_del['Creado por']
del df_del['Nombre responsable anulación' ]
del df_del['Indicador']
del df_del['Episodio']
del df_del['Tiempo anulacion (dias)']
#Otras 

del df_del['Fecha_antes']
del df_del['Fecha']
del df_del['Edad']
del df_del['Num Dcto']
del df_del['Fecha de anulación']
del df_del['Fecha crea.']
del df_del['Motivo de anulación de una citación']
del df_del['Tipo de Cita']
#del df_del['Status cita']
del df_del['Uo Plan']
#Not so sure
del df_del['Texto: causal modificación']
del df_del['Motivo de modificación']
del df_del['Comentario']
#del df_del['Nom Aseg.']
df_clean = df_del.copy()

"""# Aseguradora"""

df_aseg=df_del.copy()

df_aseg['Nom Aseg.'],_ = pd.factorize(df_aseg['Nom Aseg.'])

df5=[]
asegprinf=[]
asegprinf_no_anulada=[]
asegprinf_anulada=[]
trans_asegprinf_no_anulada= []
trans_asegprinf_anulada=[]
asegprinf_porcent_anual=[]
df5 = pd.DataFrame(df5, index=range(0, 150))
e=0

Aseg = list(range(0, 150))
EtarioV=['primera Infancia', 'infancia', 'adolescencia', 'juventud', 'adultez', 'vejez']

for e in Aseg:
  df_asegprinf = df_aseg[df_aseg['Nom Aseg.'] == e].reset_index(drop=True)

  x2 = df_asegprinf.groupby(by=["Nom Aseg.", "Indicador Anulación"])["Indicador Anulación"].count().unstack(fill_value=0, level=-1)
  nom = x2.columns.tolist()
  if 0.0 not in nom:
    x2[0.0]=0
  if 1.0 not in nom:
    x2[1.0]=0
  asegprinf.append((x2[0.0] + x2[1.0]).values[0])
  asegprinf_no_anulada.append(x2[0.0].values[0])
  asegprinf_anulada.append(x2[1.0].values[0])

  trans_asegprinf_no_anulada.append(asegprinf_no_anulada[-1] / asegprinf[-1])
  trans_asegprinf_anulada.append(asegprinf_anulada[-1] / asegprinf[-1])
  asegprinf_porcent_anual.append(asegprinf_anulada[-1] /asegprinf[-1] * 100)

df8 = pd.DataFrame(
    {"Anuladas": asegprinf_anulada, "No anuladas": asegprinf_no_anulada},
    index=range(0, 150),
)

df4 = pd.DataFrame(
    {"Anuladas": trans_asegprinf_anulada, "No anuladas": trans_asegprinf_no_anulada},
    index=range(0, 150),
)

df4['Anuladas'].plot.bar()

df5 = [round(x, 2) for x in asegprinf_porcent_anual]

print('Porcentaje de anulación')
print(df5)

df9 = pd.concat([df4, df8], axis=1)
o=0
for j in df4.index:
  if df4.loc[j, 'Anuladas'] > 0.3:
    display(df9[j:j+1])
    o+=1

plt.figure(figsize=(20,12))  # set the figure size
sn.histplot(data=df_del, x='Nom Aseg.', hue='Indicador Anulación', palette=['grey', 'green'])
plt.show()

sn.lineplot(data=df5)

del df_del['Nom Aseg.']

"""# Variables flotantes y One Hot Encoding

Hora: Cuantitativa Discretizada (puede entenderse como ordinal)
Día Semana: Categorica Ordinal
Grupo Etario: Categorica Ordinal
Tiempo Espera (días): Cuantitativa Discretizada (puede entenderse como ordinal)
Tp. plan: Categorica Nominal (hay que hacer one hot encoding)
Indicador Anulación: Binaria
"""

df_corr=df_del.copy()
del df_corr['Sala cita']
del df_corr['Tp. plan']
del df_corr['Status cita']
df_corr.head()

#One Hot Encoding
#df_del = pd.get_dummies(df_del, columns = ['Día Semana']) 
df_del = pd.get_dummies(df_del, columns = ['Tp. plan']) 
df_del = pd.get_dummies(df_del, columns = ['Sala cita']) 
df_del = pd.get_dummies(df_del, columns = ['Status cita'])

#df_corr = pd.get_dummies(df_corr, columns = ['Día Semana'])

df_del.head()

"""# Matriz de correlación"""

del df_corr['Día Semana']

#colors = sn.color_palette('Greens_r', n_colors=20)  # Paleta de colores "Greens_r" con 5 colores

corr_matrix=df_corr.corr('pearson')
sn.heatmap(corr_matrix, annot=False, annot_kws={"fontsize":6}, fmt='.3f', cmap='Greens_r')
plt.title('Correlación Pearson')

plt.show()

corr_matrix['Indicador Anulación'].sort_values(ascending=False)

"""Para distintos grupos etarios la correlación cambia"""

df_2 = df_del.copy()
df_2 = df_2.drop(df_2[df_2['Grupo Etario'] == 1.0].index)
df_del = df_del.reset_index(drop=True)
corr_matrix=df_2.corr()

sn.heatmap(corr_matrix, annot=True, annot_kws={"fontsize":6}, fmt='.3f', cmap='Greens_r')
plt.title('Corralación primera infancia')
plt.show()

"""# Covarianza

No permite evaluar la fuerza de la correlación, sin embargo permite conocer si la relación es directa (+) o inversa(-)
"""

cov_matrix = df_corr.cov()
cov_matrix['Indicador Anulación']

"""# Estadistica descriptiva"""

for i in range(len(df_corr.columns)):
  estadisticos = df_corr[df_corr.columns[i]].describe()
  print(df_corr.columns[i]+'\n')
  print(estadisticos)
  print('\n')

  # Crear una figura con dos subplots
  fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(10, 4))

  # Dibujar el histograma en el primer subplot
  sn.histplot(x=df_corr[df_corr.columns[i]], hue=df_corr['Indicador Anulación'], ax=ax1, palette=['grey', 'green'])
  ax1.set_title('Histograma')

  # Dibujar el gráfico de densidad de kernel en el segundo subplot
  sn.kdeplot(x=df_corr[df_corr.columns[i]], hue=df_corr['Indicador Anulación'], ax=ax2,  palette=['grey', 'green'])
  # ESTE NO ES sn.kdeplot(df_del[df_del.columns[i]], shade=True, ax=ax2, color=['green', 'grey'])
  
  #sn.countplot(df_del['Grupo Etario'], ax=ax2)
  ax2.set_title('Gráfico de densidad de kernel')

  # Mostrar la figura
  plt.show()

"""# Inasistencia para cada grupo etario por hora"""

df5=[]
df5 = pd.DataFrame(df5, index=range(6, 24))

Etario= list(range(1, 13)) #[1, 2, 3, 4, 5, 6] 
EtarioV=list(range(1, 13))#['primera Infancia', 'infancia', 'adolescencia', 'juventud', 'adultez', 'vejez']

def update_plot(frame):
  e = Etario[frame]
  df_delprinf = df_del[df_del['Grupo Etario'] == e].reset_index(drop=True) #Recorre la columna grupo etario separando unicamente los valores de una categoria
  horaprinf = pd.Series(index=range(6, 24), dtype=float) #Genera arreglo con los indices como horas posibles
  horaprinf_no_anulada = pd.Series(index=range(6, 24), dtype=float) #Genera arreglo con los indices como horas posibles
  horaprinf_anulada = pd.Series(index=range(6, 24), dtype=float) #Genera arreglo con los indices como horas posibles

  x = df_delprinf.groupby(by=["Hora", "Indicador Anulación"])["Indicador Anulación"].count().unstack(level=-1, fill_value=0)
  nom = x.columns.tolist()
  if 0.0 not in nom:
    x[0.0]=0
  if 1.0 not in nom:
    x[1.0]=0
  

  
  horaprinf.update(x[0] + x[1])
  horaprinf_no_anulada.update(x[0])
  horaprinf_anulada.update(x[1])
  
  trans_horaprinf_no_anulada = horaprinf_no_anulada / horaprinf
  trans_horaprinf_anulada = horaprinf_anulada / horaprinf

  horaprinf_porcent_anual = horaprinf_anulada / horaprinf * 100

  df4 = pd.DataFrame({"Anuladas": trans_horaprinf_anulada, "No anuladas": trans_horaprinf_no_anulada},index=range(6, 24))
  ax.clear() # Limpiar la figura para dibujar el siguiente gráfico
  df4.plot.bar(color=['green', 'grey'], ax=ax)
  ax.set_title(EtarioV[e-1])
  plt.close()
  #plt.show()

  horaprinf_porcent_anual_array = horaprinf_porcent_anual.apply(lambda x: round(x, 2)).values
  df5[EtarioV[e-1]]=(horaprinf_porcent_anual_array)
  return df5

fig, ax = plt.subplots()
anim = animation.FuncAnimation(fig, update_plot, frames=len(Etario))
HTML(anim.to_jshtml())

df5

print('Porcentaje de anulación'+'\n')
#display(df5)
n=0
f=['0-9', '10-19','20-27','28-33','34-40','41-47','48-53','54-59','60-65','66-72','73-79','80-98' ]
def update_line(frame):
  global n
  n=n+1
  plt.figure(figsize=(14,6))
  plt.title("Porcentaje de anulación por hora")
  ax.clear() # Limpiar la figura para dibujar el siguiente gráfico
  sn.lineplot(data=df5[frame+1], ax=ax, color='Green')
  plt.xlabel("Hora")
  plt.ylabel("Porcentaje")
  plt.close()
  
fig, ax = plt.subplots()
anim = animation.FuncAnimation(fig, update_line, frames=12)
HTML(anim.to_jshtml())
anim.save('animacion.gif', writer='imagemagick')

u=df5.idxmax()
n=u.value_counts()
x = list(n.keys())
y = list(n.values)
plt.bar(x,y,color=['green'])
plt.title('Hora de maxima cancelación')
plt.xlabel('Hora')
plt.ylabel('Cantidad de Grupos Etarios')

"""# Inasistencia para cada grupo etario por día"""

df4=[]
df4 = pd.DataFrame(df4, index=['Lunes', 'Martes','Miercoles','Jueves', 'Viernes','Sabado','Domingo'])

def update_ploti(frame):
  e = Etario[frame]
  df_delprinf = df_del.drop(df_del[df_del['Grupo Etario'] != e].index)
  df_delprinf = df_delprinf.reset_index(drop=True)
  n=1
  sumdayprinf=[]
  sumdayprinf_no_anulada=[]
  sumdayprinf_anulada=[]
  trans_sumdayprinf_no_anulada=[]
  trans_sumdayprinf_anulada=[]


  x1=df_delprinf.groupby(by=["Día Semana","Indicador Anulación"])["Indicador Anulación"].count()#.reset_index(name="count")

  while n<=7:
    sumdayprinf.append(x1[n][0]+x1[n][1])
    sumdayprinf_no_anulada.append(x1[n][0])
    sumdayprinf_anulada.append(x1[n][1])
    n+=1
  n=0
  for i, (no_anulada, anulada) in enumerate(zip(sumdayprinf_no_anulada, sumdayprinf_anulada)):
    trans_sumdayprinf_no_anulada.append(no_anulada/sumdayprinf[i])
    trans_sumdayprinf_anulada.append(anulada/sumdayprinf[i])

  sumdayprinf_porcent_anual = [round (int(a) / int(b)*100, 2) for a,b in zip(sumdayprinf_anulada,	sumdayprinf)] #porcentaje de asistencia
  
  
  df3 = pd.DataFrame(list(zip(trans_sumdayprinf_anulada, trans_sumdayprinf_no_anulada)),columns =['Anuladas', 'No anuladas'],index=['Lunes', 'Martes','Miercoles','Jueves', 'Viernes','Sabado','Domingo'])
  df4[EtarioV[e-1]]=(sumdayprinf_porcent_anual)
  ax.clear()
  df3.plot.bar(color=['green','grey'],ax=ax)
  ax.set_title(EtarioV[e-1])
  plt.close()

#print('Porcentaje de anulación')
#print(df4)
fig, ax = plt.subplots()
anim = animation.FuncAnimation(fig, update_ploti, frames=len(Etario))
HTML(anim.to_jshtml())

df4

print('Porcentaje de anulación')

#sn.lineplot(data=df4)

print('Porcentaje de anulación'+'\n')
#display(df5)

f=['0-9', '10-19','20-27','28-33','34-40','41-47','48-53','54-59','60-65','66-72','73-79','80-98' ]

plt.figure(figsize=(14,6))

plt.title("Porcentaje de anulación por hora")
for n in range(1,7):
  sn.lineplot(data=df4[n], label=f[n-1])
for n in range(8,13):
  sn.lineplot(data=df4[n], label=f[n-1])
# Add label for horizontal axis
plt.xlabel("Hora")
plt.ylabel("Porcentaje")

u=df4.idxmax()
n=u.value_counts()
x = list(n.keys())
y = list(n.values)

plt.bar(x,y,color=['green'])
plt.title('Día de maxima cancelación')
plt.xlabel('Día')
plt.ylabel('Cantidad de Grupos Etarios')

"""#Pairplot"""

#sn.pairplot(df_corr, hue= 'Indicador Anulación', palette=['grey', 'green'])

#sn.swarmplot(x=df_del['Indicador Anulación'], y=df_del['Día Semana'])

"""# Boxplot"""

sn.boxplot(x='Indicador Anulación', y='Tiempo Espera (dias)', data=df_del, palette=['grey', 'green'], showfliers=False)

from scipy.stats import mannwhitneyu

Tiemp0=df_del['Tiempo Espera (dias)'][df_del['Indicador Anulación']==0]
Tiemp1=df_del['Tiempo Espera (dias)'][df_del['Indicador Anulación']==1]

stat, pval = mannwhitneyu(Tiemp0, Tiemp1)
print('stat') # Existe una diferencia en la mediana
print('pval') # La diferencia en la distribución no es estadisticamente significativa

stat

sn.boxplot(x='Grupo Etario', y='Tiempo Espera (dias)', hue='Indicador Anulación', data=df_del, palette=['grey', 'green'], showfliers=False)

sn.boxplot(x='Grupo Etario', y='Hora', hue='Indicador Anulación', data=df_del, palette=['grey', 'green'])

df_del.head()

"""#Visualización de día de la semana, grupo etario y hora"""

def VisGraph(var, rang):
  dato = pd.Series(dtype=float)
  dato_no_anulada = pd.Series(dtype=float)
  dato_anulada = pd.Series(dtype=float)

  j = df_del.groupby(by=[var, "Indicador Anulación"])["Indicador Anulación"].count().unstack(level=-1, fill_value=0)
  nom = j.columns.tolist()

  dato = dato.append(j[0] + j[1])
  dato_no_anulada = dato_no_anulada.append(j[0])
  dato_anulada = dato_anulada.append(j[1])

  trans_dato_no_anulada = dato_no_anulada / dato
  trans_dato_anulada = dato_anulada / dato
  dato_porcent = dato_anulada / dato * 100

  df5 = pd.DataFrame({"Anuladas": dato_anulada, "No anuladas": dato_no_anulada}, index=rang)
  df4 = pd.DataFrame({"Anuladas": trans_dato_anulada, "No anuladas": trans_dato_no_anulada},index=rang)

  print('\n'+'Estadisticos de '+ var +'\n')
  print(df_del[var].describe())
  print('\n')
  fig, axs = plt.subplots(1, 5, figsize=(30,5))

  sn.kdeplot(x=var,hue='Indicador Anulación',data=df_del, palette=['grey', 'green'], ax=axs[0])
  axs[0].set_title('KDE Plot')

  sn.histplot(x=var,hue='Indicador Anulación',data=df_del, palette=['grey', 'green'], ax=axs[1])
  axs[1].set_title('Histograma')

  sn.boxplot(y=var, x='Indicador Anulación', data=df_del, palette=['grey', 'green'], ax=axs[2])
  axs[2].set_title('Box Plot')

  #df5.plot.bar(color=['green','grey'])

  df4.plot.bar(color=['green','grey'],ax=axs[3])
  axs[3].set_title('Bar Plot Porcentaje de anulación')

  dato_porcent_array = dato_porcent.apply(lambda x: round(x, 2)).values
  df6 = pd.DataFrame({"Anulación (%) por " + var: dato_porcent_array}, index=rang)

  sn.lineplot(palette=['green'], data=df6, ax= axs[4])
  axs[4].set_title('Line Chart Porcentaje de anulación')

  #plt.title('Histograma de hora normalizado')
  plt.show()
  print('\n')

  df7=df6.T
  display(df7)

info = [('Hora', range(6, 24)), ('Día Semana', range(1, 8)), ('Grupo Etario', range(1, 13))]
for var, rang in info:
    VisGraph(var, rang)

"""# Clasificador"""

df_del = pd.get_dummies(df_del, columns = ['Día Semana'])

df_del.head()

del df_del['Status cita_CONFIRMADO CON ADULTO']
del df_del['Status cita_CONFIRMADO CON PACIENTE']
del df_del['Status cita_PACIENTE NO UBICADO']

df_c=df_del.copy()
Y=df_c.pop('Indicador Anulación')
X=df_c
x_train,x_test,y_train,y_test= train_test_split(X,Y,random_state=0, stratify=Y)

warnings.filterwarnings('ignore')
scalers = [StandardScaler(), MinMaxScaler(),RobustScaler(), PowerTransformer()]
balancing_names = {'UnderSampler': RandomUnderSampler(random_state=0),
                   'OverSampler': RandomOverSampler(random_state=0),
                   'SMOTE': SMOTE(random_state=0)}
balancing_names['UnderSampler']
balancing=[RandomUnderSampler(random_state=0),
           RandomOverSampler(random_state=0),
           SMOTE(random_state=0)]
rfc= RandomForestClassifier(n_estimators=100, random_state=42)
for sc in scalers:
  for bal in balancing:
    pipeb = make_pipeline(sc,bal,rfc)
    pipeb.fit(x_train, y_train)
    train_score = pipeb.score(x_train, y_train)
    test_score = pipeb.score(x_test, y_test)
    print(f'train score{sc,bal}: {train_score}')
    print(f'test score{sc,bal}: {test_score}')

rfc=RandomForestClassifier(n_estimators=100, random_state=42)
pipeb = make_pipeline(StandardScaler(),SMOTE(random_state=0),rfc)
pipeb.fit(x_train, y_train)
train_score = pipeb.score(x_train, y_train)
test_score = pipeb.score(x_test, y_test)
print(f'train score{sc,bal}: {train_score}')
print(f'test score{sc,bal}: {test_score}')

df_del.head()

X_new = df_c[13:14]

# Preprocesa el dato
X_new_processed = pipeb.named_steps['standardscaler'].transform(X_new)

# Haz la predicción con el modelo
y_predpr = pipeb.predict_proba(X_new_processed)
y_pred = pipeb.predict(X_new_processed)

# Imprime la predicción
print(y_pred)
print(y_predpr)

from sklearn.metrics import confusion_matrix, precision_score, recall_score, f1_score, roc_auc_score, classification_report

# Calcular las predicciones del conjunto de entrenamiento y de prueba
y_train_pred = pipeb.predict(x_train)
y_test_pred = pipeb.predict(x_test)

# Calcular la matriz de confusión del conjunto de entrenamiento y de prueba
cm_train = confusion_matrix(y_train, y_train_pred)
cm_test = confusion_matrix(y_test, y_test_pred)

print('Matriz de confusión (entrenamiento):\n', cm_train)
print('Matriz de confusión (prueba):\n', cm_test)

y_pred = pipeb.predict(x_test)
print(classification_report(y_test,y_pred))

df_del.head()

importances = pipeb.named_steps['randomforestclassifier'].feature_importances_
std = np.std([tree.feature_importances_ for tree in pipeb.named_steps['randomforestclassifier'].estimators_], axis=0)
indices = np.argsort(importances)[::-1]

# Graficar las importancias de las características
plt.figure(figsize=(10, 5))
plt.title("Importancia de las características")
plt.bar(range(x_train.shape[1]), importances[indices], color="g", yerr=std[indices], align="center")
plt.xticks(range(x_train.shape[1]), x_train.columns[indices], rotation=90)
plt.xlim([-1, x_train.shape[1]])
plt.tight_layout()
plt.show()

from sklearn.feature_selection import SelectKBest,f_classif,f_regression


bestfeatures = SelectKBest(score_func=f_classif, k=10)
X_n = bestfeatures.fit(X,Y)

dfscores = pd.DataFrame(X_n.scores_)
dfcolumns = pd.DataFrame(X.columns)
#concat two dataframes for better visualization 
featureScores = pd.concat([dfcolumns,dfscores],axis=1)
featureScores.columns = ['Specs','Score']  #naming the dataframe columns
mejores=featureScores.nlargest(10,'Score')  #print 10 best features

z=X.drop(mejores['Specs'],axis=1)
x=X.drop(z,axis=1)
mejores

Tiempoesp = pd.Series(dtype=float)
Tiempoesp_no_anulada = pd.Series(dtype=float)
Tiempoesp_anulada = pd.Series(dtype=float)

j = df_del.groupby(by=["Tiempo Espera (dias)", "Indicador Anulación"])["Indicador Anulación"].count().unstack(level=-1, fill_value=0)
nom = j.columns.tolist()

Tiempoesp = Tiempoesp.append(j[0] + j[1])
Tiempoesp_no_anulada = Tiempoesp_no_anulada.append(j[0])
Tiempoesp_anulada = Tiempoesp_anulada.append(j[1])

trans_Tiempoesp_no_anulada = Tiempoesp_no_anulada / Tiempoesp
trans_Tiempoesp_anulada = Tiempoesp_anulada / Tiempoesp
Tiempoesp_porcent = Tiempoesp_anulada / Tiempoesp * 100

fig, axs = plt.subplots(1, 3, figsize=(30,5))

sn.kdeplot(x='Tiempo Espera (dias)',hue='Indicador Anulación',data=df_del, palette=['grey', 'green'], ax=axs[0])
axs[0].set_title('KDE Plot')

sn.histplot(x='Tiempo Espera (dias)',hue='Indicador Anulación',data=df_del, palette=['grey', 'green'], ax=axs[1])
axs[1].set_title('Histogram')

sn.boxplot(y='Tiempo Espera (dias)', x='Indicador Anulación', data=df_del, palette=['grey', 'green'], ax=axs[2])
axs[2].set_title('Box Plot')

plt.show()

Tiempoesp_porcent_array = Tiempoesp_porcent.apply(lambda x: round(x, 2)).values
print('Porcentaje de anulación')
print(Tiempoesp_porcent_array)

names